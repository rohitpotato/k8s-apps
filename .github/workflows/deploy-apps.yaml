name: Deploy Apps
on:
  push:
    branches: [main]

env:
  REGISTRY: ghcr.io

jobs:
  deploy-apps:
    name: Deploy Apps
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login into registry
        uses: docker/login-action@v3.3.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate Kubernetes manifests
        run: |
          # Install kubeconform (modern replacement for kubeval)
          curl -L https://github.com/yannh/kubeconform/releases/latest/download/kubeconform-linux-amd64.tar.gz | tar xz
          sudo mv kubeconform /usr/local/bin

          # Find Kubernetes manifests (exclude .github and other non-k8s directories)
          MANIFEST_FILES=$(find . -name "*.yaml" -o -name "*.yml" | grep -v ".github" | grep -v ".git" || true)

          if [ -z "$MANIFEST_FILES" ]; then
            echo "No Kubernetes manifest files found"
            exit 1
          fi

          echo "Validating Kubernetes manifests:"
          echo "$MANIFEST_FILES"

          # Validate all manifests with kubeconform
          # -summary: show summary
          # -output json: better error reporting  
          # -ignore-missing-schemas: don't fail on missing CRD schemas
          echo "$MANIFEST_FILES" | xargs kubeconform -summary -ignore-missing-schemas

      - name: Deploy to Kubernetes
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          passphrase: ${{ secrets.PASSPHRASE }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true # Stop on first error
          envs: GITHUB_ACTOR,GITHUB_TOKEN
          script: |
            set -e  # Exit on any error

            echo "üöÄ Starting deployment process..."

            # Setup kubeconfig for k3s FIRST
            echo "üîß Setting up kubeconfig..."
            mkdir -p ~/.kube

            # Copy k3s config to user directory
            if [ -f /etc/rancher/k3s/k3s.yaml ]; then
              echo "üìã Copying k3s config to ~/.kube/config"
              cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
              chmod 600 ~/.kube/config
              echo "‚úÖ kubeconfig copied and permissions set"
            else
              echo "‚ùå k3s config not found at /etc/rancher/k3s/k3s.yaml"
              exit 1
            fi

            # Set kubeconfig environment variable
            export KUBECONFIG=~/.kube/config
            echo "‚úÖ KUBECONFIG set to ~/.kube/config"

            # Test kubectl connection
            echo "üîç Testing kubectl connection..."
            if kubectl cluster-info >/dev/null 2>&1; then
              echo "‚úÖ kubectl can connect to cluster"
            else
              echo "‚ùå kubectl cannot connect to cluster"
              exit 1
            fi

            # Create backup directory if it doesn't exist
            echo "üìÅ Creating backup directory..."
            mkdir -p ~/k8s-backups
            echo "‚úÖ Backup directory created"

            # Create namespace if it doesn't exist
            echo "üì¶ Creating namespace monospaced..."
            kubectl create namespace monospaced --dry-run=client -o yaml | kubectl apply -f -
            echo "‚úÖ Namespace ready"

            # Backup current deployment for rollback (only if there are resources)
            echo "üíæ Creating backup of current deployment..."
            if kubectl get all -n monospaced --no-headers 2>/dev/null | grep -q .; then
              kubectl get all -n monospaced -o yaml > ~/k8s-backups/backup-$(date +%Y%m%d-%H%M%S).yaml
              echo "‚úÖ Backup created"
            else
              echo "‚ÑπÔ∏è  No existing resources to backup"
            fi

            # Check if cert-manager is already installed
            echo "üîê Checking cert-manager installation..."
            echo "üîç About to run: kubectl get namespace cert-manager"

            # Run the command and capture both output and exit code
            if kubectl get namespace cert-manager 2>&1; then
              CERT_MANAGER_EXISTS=true
              echo "‚úÖ cert-manager namespace found"
            else
              CERT_MANAGER_EXISTS=false
              echo "‚ÑπÔ∏è  cert-manager namespace not found (this is expected for first install)"
            fi

            echo "üîç Cert-manager exists: $CERT_MANAGER_EXISTS"

            if [ "$CERT_MANAGER_EXISTS" = "false" ]; then
              echo "üì¶ Installing cert-manager..."
              
              # Install cert-manager
              echo "üì• Downloading and applying cert-manager manifests..."
              kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.yaml
              echo "‚úÖ cert-manager manifests applied"
              
              # Wait for cert-manager to be ready
              echo "‚è≥ Waiting for cert-manager to be ready..."
              kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager
              kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-cainjector -n cert-manager
              kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-webhook -n cert-manager
              
              echo "‚úÖ cert-manager installed successfully"
            else
              echo "‚úÖ cert-manager already exists, skipping installation"
            fi

            echo "üéØ cert-manager check completed, proceeding to manifests..."

            # Create temporary directory for manifests
            echo "üìÇ Creating temporary directory for manifests..."
            TEMP_DIR=$(mktemp -d)
            echo "üìç Temporary directory: $TEMP_DIR"
            cd "$TEMP_DIR"

            # Clone the repository using the branch (more reliable than SHA)
            echo "üì• Cloning repository..."
            git clone --depth 1 --branch main https://github.com/${{ github.repository }}.git . || {
              echo "‚ùå Failed to clone repository"
              exit 1
            }
            echo "‚úÖ Repository cloned successfully"

            # Dynamically find all directories containing Kubernetes manifests (exclude .github)
            echo "üîç Finding Kubernetes manifest directories..."
            MANIFEST_DIRS=$(find . -name "*.yaml" -o -name "*.yml" | grep -v ".github" | grep -v ".git" | xargs dirname | sort -u | grep -v '^\.$' || true)

            if [ -z "$MANIFEST_DIRS" ]; then
              echo "‚ùå No Kubernetes manifest directories found"
              exit 1
            fi

            echo "üìã Found manifest directories:"
            echo "$MANIFEST_DIRS"

            # Apply manifests from each directory
            echo "üöÄ Applying manifests..."
            for dir in $MANIFEST_DIRS; do
              echo "üìÅ Applying manifests from: $dir"
              kubectl apply -f "$dir/" --recursive || {
                echo "‚ùå Failed to apply manifests from $dir"
                exit 1
              }
              echo "‚úÖ Applied manifests from $dir"
            done

            # Clean up temporary directory
            echo "üßπ Cleaning up temporary directory..."
            cd ~
            rm -rf "$TEMP_DIR"
            echo "‚úÖ Cleanup completed"

            # Dynamically find all deployments in the monospaced namespace and wait for them
            echo "‚è≥ Waiting for deployments to be ready..."
            DEPLOYMENTS=$(kubectl get deployments -n monospaced -o name 2>/dev/null || true)

            if [ -n "$DEPLOYMENTS" ]; then
              for deployment in $DEPLOYMENTS; do
                echo "‚è≥ Waiting for $deployment to be ready..."
                kubectl wait --for=condition=available --timeout=300s "$deployment" -n monospaced || {
                  echo "‚ùå $deployment failed to become ready"
                  exit 1
                }
                echo "‚úÖ $deployment is ready"
              done
            else
              echo "‚ÑπÔ∏è  No deployments found in monospaced namespace"
            fi

            # Verify pods are running
            echo "üîç Verifying pods..."
            kubectl get pods -n monospaced

            # Basic health check
            echo "üîç Checking services..."
            kubectl get services -n monospaced

            echo "üéâ Deployment completed successfully!"

      - name: Notify on success
        if: success()
        run: echo "‚úÖ Deployment completed successfully"

      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed"
          exit 1
