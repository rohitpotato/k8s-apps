name: Deploy Apps
on:
  push:
    branches: [main]

env:
  REGISTRY: ghcr.io

jobs:
  deploy-apps:
    name: Deploy Apps
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login into registry
        uses: docker/login-action@v3.3.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate Kubernetes manifests
        run: |
          # Install kubeconform (modern replacement for kubeval)
          curl -L https://github.com/yannh/kubeconform/releases/latest/download/kubeconform-linux-amd64.tar.gz | tar xz
          sudo mv kubeconform /usr/local/bin

          # Find Kubernetes manifests (exclude .github and other non-k8s directories)
          MANIFEST_FILES=$(find . -name "*.yaml" -o -name "*.yml" | grep -v ".github" | grep -v ".git" || true)

          if [ -z "$MANIFEST_FILES" ]; then
            echo "No Kubernetes manifest files found"
            exit 1
          fi

          echo "Validating Kubernetes manifests:"
          echo "$MANIFEST_FILES"

          # Validate all manifests with kubeconform
          # -summary: show summary
          # -output json: better error reporting  
          # -ignore-missing-schemas: don't fail on missing CRD schemas
          echo "$MANIFEST_FILES" | xargs kubeconform -summary -ignore-missing-schemas

      - name: Deploy to Kubernetes
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          passphrase: ${{ secrets.PASSPHRASE }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true # Stop on first error
          envs: GITHUB_ACTOR,GITHUB_TOKEN
          script: |
            set -e  # Exit on any error

            # Create backup directory if it doesn't exist
            mkdir -p ~/k8s-backups

            # Create namespace if it doesn't exist
            kubectl create namespace monospaced --dry-run=client -o yaml | kubectl apply -f -

            # Backup current deployment for rollback
            kubectl get all -n monospaced -o yaml > ~/k8s-backups/backup-$(date +%Y%m%d-%H%M%S).yaml || true

            # Check if cert-manager is already installed
            if ! kubectl get namespace cert-manager &>/dev/null; then
              echo "Installing cert-manager..."
              
              # Install cert-manager
              kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.yaml
              
              # Wait for cert-manager to be ready
              echo "Waiting for cert-manager to be ready..."
              kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager
              kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-cainjector -n cert-manager
              kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-webhook -n cert-manager
              
              echo "cert-manager installed successfully"
            else
              echo "cert-manager already exists, skipping installation"
            fi

            # Create temporary directory for manifests
            TEMP_DIR=$(mktemp -d)
            cd "$TEMP_DIR"

            # Clone the repository using the branch (more reliable than SHA)
            git clone --depth 1 --branch main https://github.com/${{ github.repository }}.git .

            # Dynamically find all directories containing Kubernetes manifests (exclude .github)
            MANIFEST_DIRS=$(find . -name "*.yaml" -o -name "*.yml" | grep -v ".github" | grep -v ".git" | xargs dirname | sort -u | grep -v '^\.$' || true)

            if [ -z "$MANIFEST_DIRS" ]; then
              echo "No Kubernetes manifest directories found"
              exit 1
            fi

            echo "Found manifest directories:"
            echo "$MANIFEST_DIRS"

            # Apply manifests from each directory
            for dir in $MANIFEST_DIRS; do
              echo "Applying manifests from: $dir"
              kubectl apply -f "$dir/" --recursive
            done

            # Clean up temporary directory
            cd ~
            rm -rf "$TEMP_DIR"

            # Dynamically find all deployments in the monospaced namespace and wait for them
            echo "Waiting for deployments to be ready..."
            DEPLOYMENTS=$(kubectl get deployments -n monospaced -o name 2>/dev/null || true)

            if [ -n "$DEPLOYMENTS" ]; then
              for deployment in $DEPLOYMENTS; do
                echo "Waiting for $deployment to be ready..."
                kubectl wait --for=condition=available --timeout=300s "$deployment" -n monospaced || {
                  echo "$deployment failed to become ready"
                  exit 1
                }
              done
            else
              echo "No deployments found in monospaced namespace"
            fi

            # Verify pods are running
            kubectl get pods -n monospaced

            # Basic health check
            kubectl get services -n monospaced

            echo "Deployment completed successfully!"

      - name: Notify on success
        if: success()
        run: echo "✅ Deployment completed successfully"

      - name: Notify on failure
        if: failure()
        run: |
          echo "❌ Deployment failed"
          exit 1
